# generated by datamodel-codegen:
#   filename:  a2a.json
#   timestamp: 2025-06-04T23:23:49+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import BaseModel, Field, RootModel


class Model(RootModel[Any]):
    root: Any


class In(Enum):
    cookie = 'cookie'
    header = 'header'
    query = 'query'


class APIKeySecurityScheme(BaseModel):
    description: Optional[str] = Field(
        None, description='Description of this security scheme.'
    )
    in_: In = Field(
        ...,
        alias='in',
        description='The location of the API key. Valid values are "query", "header", or "cookie".',
    )
    name: str = Field(
        ..., description='The name of the header, query or cookie parameter to be used.'
    )
    type: Literal['apiKey']


class AgentExtension(BaseModel):
    description: Optional[str] = Field(
        None, description='A description of how this agent uses this extension.'
    )
    params: Optional[Dict[str, Any]] = Field(
        None, description='Optional configuration for the extension.'
    )
    required: Optional[bool] = Field(
        None,
        description='Whether the client must follow specific requirements of the extension.',
    )
    uri: str = Field(..., description='The URI of the extension.')


class AgentProvider(BaseModel):
    organization: str = Field(..., description="Agent provider's organization name.")
    url: str = Field(..., description="Agent provider's URL.")


class AgentSkill(BaseModel):
    description: str = Field(
        ...,
        description='Description of the skill - will be used by the client or a human\nas a hint to understand what the skill does.',
    )
    examples: Optional[List[str]] = Field(
        None,
        description='The set of example scenarios that the skill can perform.\nWill be used by the client as a hint to understand how the skill can be used.',
    )
    id: str = Field(..., description="Unique identifier for the agent's skill.")
    inputModes: Optional[List[str]] = Field(
        None,
        description='The set of interaction modes that the skill supports\n(if different than the default).\nSupported media types for input.',
    )
    name: str = Field(..., description='Human readable name of the skill.')
    outputModes: Optional[List[str]] = Field(
        None, description='Supported media types for output.'
    )
    tags: List[str] = Field(
        ...,
        description='Set of tagwords describing classes of capabilities for this specific skill.',
    )


class AuthorizationCodeOAuthFlow(BaseModel):
    authorizationUrl: str = Field(
        ...,
        description='The authorization URL to be used for this flow. This MUST be in the form of a URL. The OAuth2\nstandard requires the use of TLS',
    )
    refreshUrl: Optional[str] = Field(
        None,
        description='The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2\nstandard requires the use of TLS.',
    )
    scopes: Dict[str, str] = Field(
        ...,
        description='The available scopes for the OAuth2 security scheme. A map between the scope name and a short\ndescription for it. The map MAY be empty.',
    )
    tokenUrl: str = Field(
        ...,
        description='The token URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard\nrequires the use of TLS.',
    )


class ClientCredentialsOAuthFlow(BaseModel):
    refreshUrl: Optional[str] = Field(
        None,
        description='The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2\nstandard requires the use of TLS.',
    )
    scopes: Dict[str, str] = Field(
        ...,
        description='The available scopes for the OAuth2 security scheme. A map between the scope name and a short\ndescription for it. The map MAY be empty.',
    )
    tokenUrl: str = Field(
        ...,
        description='The token URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard\nrequires the use of TLS.',
    )


class ContentTypeNotSupportedError(BaseModel):
    code: Literal[-32005] = Field(
        ..., description='A Number that indicates the error type that occurred.'
    )
    data: Optional[Any] = Field(
        None,
        description='A Primitive or Structured value that contains additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(
        ..., description='A String providing a short description of the error.'
    )


class DataPart(BaseModel):
    data: Dict[str, Any] = Field(..., description='Structured data content')
    kind: Literal['data'] = Field(..., description='Part type - data for DataParts')
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Optional metadata associated with the part.'
    )


class FileBase(BaseModel):
    mimeType: Optional[str] = Field(None, description='Optional mimeType for the file')
    name: Optional[str] = Field(None, description='Optional name for the file')


class FileWithBytes(BaseModel):
    bytes: str = Field(..., description='base64 encoded content of the file')
    mimeType: Optional[str] = Field(None, description='Optional mimeType for the file')
    name: Optional[str] = Field(None, description='Optional name for the file')


class FileWithUri(BaseModel):
    mimeType: Optional[str] = Field(None, description='Optional mimeType for the file')
    name: Optional[str] = Field(None, description='Optional name for the file')
    uri: str = Field(..., description='URL for the File content')


class HTTPAuthSecurityScheme(BaseModel):
    bearerFormat: Optional[str] = Field(
        None,
        description='A hint to the client to identify how the bearer token is formatted. Bearer tokens are usually\ngenerated by an authorization server, so this information is primarily for documentation\npurposes.',
    )
    description: Optional[str] = Field(
        None, description='Description of this security scheme.'
    )
    scheme: str = Field(
        ...,
        description='The name of the HTTP Authentication scheme to be used in the Authorization header as defined\nin RFC7235. The values used SHOULD be registered in the IANA Authentication Scheme registry.\nThe value is case-insensitive, as defined in RFC7235.',
    )
    type: Literal['http']


class ImplicitOAuthFlow(BaseModel):
    authorizationUrl: str = Field(
        ...,
        description='The authorization URL to be used for this flow. This MUST be in the form of a URL. The OAuth2\nstandard requires the use of TLS',
    )
    refreshUrl: Optional[str] = Field(
        None,
        description='The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2\nstandard requires the use of TLS.',
    )
    scopes: Dict[str, str] = Field(
        ...,
        description='The available scopes for the OAuth2 security scheme. A map between the scope name and a short\ndescription for it. The map MAY be empty.',
    )


class InternalError(BaseModel):
    code: Literal[-32603] = Field(
        ..., description='A Number that indicates the error type that occurred.'
    )
    data: Optional[Any] = Field(
        None,
        description='A Primitive or Structured value that contains additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(
        ..., description='A String providing a short description of the error.'
    )


class InvalidAgentResponseError(BaseModel):
    code: Literal[-32006] = Field(
        ..., description='A Number that indicates the error type that occurred.'
    )
    data: Optional[Any] = Field(
        None,
        description='A Primitive or Structured value that contains additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(
        ..., description='A String providing a short description of the error.'
    )


class InvalidParamsError(BaseModel):
    code: Literal[-32602] = Field(
        ..., description='A Number that indicates the error type that occurred.'
    )
    data: Optional[Any] = Field(
        None,
        description='A Primitive or Structured value that contains additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(
        ..., description='A String providing a short description of the error.'
    )


class InvalidRequestError(BaseModel):
    code: Literal[-32600] = Field(
        ..., description='A Number that indicates the error type that occurred.'
    )
    data: Optional[Any] = Field(
        None,
        description='A Primitive or Structured value that contains additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(
        ..., description='A String providing a short description of the error.'
    )


class JSONParseError(BaseModel):
    code: Literal[-32700] = Field(
        ..., description='A Number that indicates the error type that occurred.'
    )
    data: Optional[Any] = Field(
        None,
        description='A Primitive or Structured value that contains additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(
        ..., description='A String providing a short description of the error.'
    )


class JSONRPCError(BaseModel):
    code: int = Field(
        ..., description='A Number that indicates the error type that occurred.'
    )
    data: Optional[Any] = Field(
        None,
        description='A Primitive or Structured value that contains additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(
        ..., description='A String providing a short description of the error.'
    )


class JSONRPCMessage(BaseModel):
    id: Optional[Union[str, int]] = Field(
        None,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )


class JSONRPCRequest(BaseModel):
    id: Optional[Union[str, int]] = Field(
        None,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )
    method: str = Field(
        ..., description='A String containing the name of the method to be invoked.'
    )
    params: Optional[Dict[str, Any]] = Field(
        None,
        description='A Structured value that holds the parameter values to be used during the invocation of the method.',
    )


class JSONRPCSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ...,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )
    result: Any = Field(..., description='The result object on success')


class Role(Enum):
    agent = 'agent'
    user = 'user'


class MethodNotFoundError(BaseModel):
    code: Literal[-32601] = Field(
        ..., description='A Number that indicates the error type that occurred.'
    )
    data: Optional[Any] = Field(
        None,
        description='A Primitive or Structured value that contains additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(
        ..., description='A String providing a short description of the error.'
    )


class OpenIdConnectSecurityScheme(BaseModel):
    description: Optional[str] = Field(
        None, description='Description of this security scheme.'
    )
    openIdConnectUrl: str = Field(
        ...,
        description='Well-known URL to discover the [[OpenID-Connect-Discovery]] provider metadata.',
    )
    type: Literal['openIdConnect']


class PartBase(BaseModel):
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Optional metadata associated with the part.'
    )


class PasswordOAuthFlow(BaseModel):
    refreshUrl: Optional[str] = Field(
        None,
        description='The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2\nstandard requires the use of TLS.',
    )
    scopes: Dict[str, str] = Field(
        ...,
        description='The available scopes for the OAuth2 security scheme. A map between the scope name and a short\ndescription for it. The map MAY be empty.',
    )
    tokenUrl: str = Field(
        ...,
        description='The token URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard\nrequires the use of TLS.',
    )


class PushNotificationAuthenticationInfo(BaseModel):
    credentials: Optional[str] = Field(None, description='Optional credentials')
    schemes: List[str] = Field(
        ..., description='Supported authentication schemes - e.g. Basic, Bearer'
    )


class PushNotificationConfig(BaseModel):
    authentication: Optional[PushNotificationAuthenticationInfo] = None
    id: Optional[str] = Field(
        None,
        description='Push Notification ID - created by server to support multiple callbacks',
    )
    token: Optional[str] = Field(None, description='Token unique to this task/session.')
    url: str = Field(..., description='URL for sending the push notifications.')


class PushNotificationNotSupportedError(BaseModel):
    code: Literal[-32003] = Field(
        ..., description='A Number that indicates the error type that occurred.'
    )
    data: Optional[Any] = Field(
        None,
        description='A Primitive or Structured value that contains additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(
        ..., description='A String providing a short description of the error.'
    )


class SecuritySchemeBase(BaseModel):
    description: Optional[str] = Field(
        None, description='Description of this security scheme.'
    )


class TaskIdParams(BaseModel):
    id: str = Field(..., description='Task id.')
    metadata: Optional[Dict[str, Any]] = None


class TaskNotCancelableError(BaseModel):
    code: Literal[-32002] = Field(
        ..., description='A Number that indicates the error type that occurred.'
    )
    data: Optional[Any] = Field(
        None,
        description='A Primitive or Structured value that contains additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(
        ..., description='A String providing a short description of the error.'
    )


class TaskNotFoundError(BaseModel):
    code: Literal[-32001] = Field(
        ..., description='A Number that indicates the error type that occurred.'
    )
    data: Optional[Any] = Field(
        None,
        description='A Primitive or Structured value that contains additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(
        ..., description='A String providing a short description of the error.'
    )


class TaskPushNotificationConfig(BaseModel):
    pushNotificationConfig: PushNotificationConfig = Field(
        ..., description='Push notification configuration.'
    )
    taskId: str = Field(..., description='Task id.')


class TaskQueryParams(BaseModel):
    historyLength: Optional[int] = Field(
        None, description='Number of recent messages to be retrieved.'
    )
    id: str = Field(..., description='Task id.')
    metadata: Optional[Dict[str, Any]] = None


class TaskResubscriptionRequest(BaseModel):
    id: Union[str, int] = Field(
        ...,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )
    method: Literal['tasks/resubscribe'] = Field(
        ..., description='A String containing the name of the method to be invoked.'
    )
    params: TaskIdParams = Field(
        ...,
        description='A Structured value that holds the parameter values to be used during the invocation of the method.',
    )


class TaskState(Enum):
    submitted = 'submitted'
    working = 'working'
    input_required = 'input-required'
    completed = 'completed'
    canceled = 'canceled'
    failed = 'failed'
    rejected = 'rejected'
    auth_required = 'auth-required'
    unknown = 'unknown'


class TextPart(BaseModel):
    kind: Literal['text'] = Field(..., description='Part type - text for TextParts')
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Optional metadata associated with the part.'
    )
    text: str = Field(..., description='Text content')


class UnsupportedOperationError(BaseModel):
    code: Literal[-32004] = Field(
        ..., description='A Number that indicates the error type that occurred.'
    )
    data: Optional[Any] = Field(
        None,
        description='A Primitive or Structured value that contains additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(
        ..., description='A String providing a short description of the error.'
    )


class A2AError(
    RootModel[
        Union[
            JSONParseError,
            InvalidRequestError,
            MethodNotFoundError,
            InvalidParamsError,
            InternalError,
            TaskNotFoundError,
            TaskNotCancelableError,
            PushNotificationNotSupportedError,
            UnsupportedOperationError,
            ContentTypeNotSupportedError,
            InvalidAgentResponseError,
        ]
    ]
):
    root: Union[
        JSONParseError,
        InvalidRequestError,
        MethodNotFoundError,
        InvalidParamsError,
        InternalError,
        TaskNotFoundError,
        TaskNotCancelableError,
        PushNotificationNotSupportedError,
        UnsupportedOperationError,
        ContentTypeNotSupportedError,
        InvalidAgentResponseError,
    ]


class AgentCapabilities(BaseModel):
    extensions: Optional[List[AgentExtension]] = Field(
        None, description='extensions supported by this agent.'
    )
    pushNotifications: Optional[bool] = Field(
        None, description='true if the agent can notify updates to client.'
    )
    stateTransitionHistory: Optional[bool] = Field(
        None, description='true if the agent exposes status change history for tasks.'
    )
    streaming: Optional[bool] = Field(
        None, description='true if the agent supports SSE.'
    )


class CancelTaskRequest(BaseModel):
    id: Union[str, int] = Field(
        ...,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )
    method: Literal['tasks/cancel'] = Field(
        ..., description='A String containing the name of the method to be invoked.'
    )
    params: TaskIdParams = Field(
        ...,
        description='A Structured value that holds the parameter values to be used during the invocation of the method.',
    )


class FilePart(BaseModel):
    file: Union[FileWithBytes, FileWithUri] = Field(
        ..., description='File content either as url or bytes'
    )
    kind: Literal['file'] = Field(..., description='Part type - file for FileParts')
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Optional metadata associated with the part.'
    )


class GetTaskPushNotificationConfigRequest(BaseModel):
    id: Union[str, int] = Field(
        ...,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )
    method: Literal['tasks/pushNotificationConfig/get'] = Field(
        ..., description='A String containing the name of the method to be invoked.'
    )
    params: TaskIdParams = Field(
        ...,
        description='A Structured value that holds the parameter values to be used during the invocation of the method.',
    )


class GetTaskPushNotificationConfigSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ...,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )
    result: TaskPushNotificationConfig = Field(
        ..., description='The result object on success.'
    )


class GetTaskRequest(BaseModel):
    id: Union[str, int] = Field(
        ...,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )
    method: Literal['tasks/get'] = Field(
        ..., description='A String containing the name of the method to be invoked.'
    )
    params: TaskQueryParams = Field(
        ...,
        description='A Structured value that holds the parameter values to be used during the invocation of the method.',
    )


class JSONRPCErrorResponse(BaseModel):
    error: Union[
        JSONRPCError,
        JSONParseError,
        InvalidRequestError,
        MethodNotFoundError,
        InvalidParamsError,
        InternalError,
        TaskNotFoundError,
        TaskNotCancelableError,
        PushNotificationNotSupportedError,
        UnsupportedOperationError,
        ContentTypeNotSupportedError,
        InvalidAgentResponseError,
    ]
    id: Optional[Union[str, int]] = Field(
        ...,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )


class MessageSendConfiguration(BaseModel):
    acceptedOutputModes: List[str] = Field(
        ..., description='Accepted output modalities by the client.'
    )
    blocking: Optional[bool] = Field(
        None, description='If the server should treat the client as a blocking request.'
    )
    historyLength: Optional[int] = Field(
        None, description='Number of recent messages to be retrieved.'
    )
    pushNotificationConfig: Optional[PushNotificationConfig] = Field(
        None,
        description='Where the server should send notifications when disconnected.',
    )


class OAuthFlows(BaseModel):
    authorizationCode: Optional[AuthorizationCodeOAuthFlow] = Field(
        None,
        description='Configuration for the OAuth Authorization Code flow. Previously called accessCode in OpenAPI 2.0.',
    )
    clientCredentials: Optional[ClientCredentialsOAuthFlow] = Field(
        None,
        description='Configuration for the OAuth Client Credentials flow. Previously called application in OpenAPI 2.0',
    )
    implicit: Optional[ImplicitOAuthFlow] = Field(
        None, description='Configuration for the OAuth Implicit flow'
    )
    password: Optional[PasswordOAuthFlow] = Field(
        None, description='Configuration for the OAuth Resource Owner Password flow'
    )


class Part(RootModel[Union[TextPart, FilePart, DataPart]]):
    root: Union[TextPart, FilePart, DataPart] = Field(
        ...,
        description='Represents a part of a message, which can be text, a file, or structured data.',
    )


class SetTaskPushNotificationConfigRequest(BaseModel):
    id: Union[str, int] = Field(
        ...,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )
    method: Literal['tasks/pushNotificationConfig/set'] = Field(
        ..., description='A String containing the name of the method to be invoked.'
    )
    params: TaskPushNotificationConfig = Field(
        ...,
        description='A Structured value that holds the parameter values to be used during the invocation of the method.',
    )


class SetTaskPushNotificationConfigSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ...,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )
    result: TaskPushNotificationConfig = Field(
        ..., description='The result object on success.'
    )


class Artifact(BaseModel):
    artifactId: str = Field(..., description='Unique identifier for the artifact.')
    description: Optional[str] = Field(
        None, description='Optional description for the artifact.'
    )
    extensions: Optional[List[str]] = Field(
        None,
        description='The URIs of extensions that are present or contributed to this Artifact.',
    )
    metadata: Optional[Dict[str, Any]] = Field(None, description='Extension metadata.')
    name: Optional[str] = Field(None, description='Optional name for the artifact.')
    parts: List[Part] = Field(..., description='Artifact parts.')


class GetTaskPushNotificationConfigResponse(
    RootModel[Union[JSONRPCErrorResponse, GetTaskPushNotificationConfigSuccessResponse]]
):
    root: Union[JSONRPCErrorResponse, GetTaskPushNotificationConfigSuccessResponse] = (
        Field(
            ...,
            description="JSON-RPC response for the 'tasks/pushNotificationConfig/set' method.",
        )
    )


class Message(BaseModel):
    contextId: Optional[str] = Field(
        None, description='The context the message is associated with'
    )
    extensions: Optional[List[str]] = Field(
        None,
        description='The URIs of extensions that are present or contributed to this Message.',
    )
    kind: Literal['message'] = Field(..., description='Event type')
    messageId: str = Field(..., description='Identifier created by the message creator')
    metadata: Optional[Dict[str, Any]] = Field(None, description='Extension metadata.')
    parts: List[Part] = Field(..., description='Message content')
    referenceTaskIds: Optional[List[str]] = Field(
        None, description='List of tasks referenced as context by this message.'
    )
    role: Role = Field(..., description="Message sender's role")
    taskId: Optional[str] = Field(
        None, description='Identifier of task the message is related to'
    )


class MessageSendParams(BaseModel):
    configuration: Optional[MessageSendConfiguration] = Field(
        None, description='Send message configuration.'
    )
    message: Message = Field(..., description='The message being sent to the server.')
    metadata: Optional[Dict[str, Any]] = Field(None, description='Extension metadata.')


class OAuth2SecurityScheme(BaseModel):
    description: Optional[str] = Field(
        None, description='Description of this security scheme.'
    )
    flows: OAuthFlows = Field(
        ...,
        description='An object containing configuration information for the flow types supported.',
    )
    type: Literal['oauth2']


class SecurityScheme(
    RootModel[
        Union[
            APIKeySecurityScheme,
            HTTPAuthSecurityScheme,
            OAuth2SecurityScheme,
            OpenIdConnectSecurityScheme,
        ]
    ]
):
    root: Union[
        APIKeySecurityScheme,
        HTTPAuthSecurityScheme,
        OAuth2SecurityScheme,
        OpenIdConnectSecurityScheme,
    ] = Field(
        ...,
        description='Mirrors the OpenAPI Security Scheme Object\n(https://swagger.io/specification/#security-scheme-object)',
    )


class SendMessageRequest(BaseModel):
    id: Union[str, int] = Field(
        ...,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )
    method: Literal['message/send'] = Field(
        ..., description='A String containing the name of the method to be invoked.'
    )
    params: MessageSendParams = Field(
        ...,
        description='A Structured value that holds the parameter values to be used during the invocation of the method.',
    )


class SendStreamingMessageRequest(BaseModel):
    id: Union[str, int] = Field(
        ...,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )
    method: Literal['message/stream'] = Field(
        ..., description='A String containing the name of the method to be invoked.'
    )
    params: MessageSendParams = Field(
        ...,
        description='A Structured value that holds the parameter values to be used during the invocation of the method.',
    )


class SetTaskPushNotificationConfigResponse(
    RootModel[Union[JSONRPCErrorResponse, SetTaskPushNotificationConfigSuccessResponse]]
):
    root: Union[JSONRPCErrorResponse, SetTaskPushNotificationConfigSuccessResponse] = (
        Field(
            ...,
            description="JSON-RPC response for the 'tasks/pushNotificationConfig/set' method.",
        )
    )


class TaskArtifactUpdateEvent(BaseModel):
    append: Optional[bool] = Field(
        None, description='Indicates if this artifact appends to a previous one'
    )
    artifact: Artifact = Field(..., description='Generated artifact')
    contextId: str = Field(..., description='The context the task is associated with')
    kind: Literal['artifact-update'] = Field(..., description='Event type')
    lastChunk: Optional[bool] = Field(
        None, description='Indicates if this is the last chunk of the artifact'
    )
    metadata: Optional[Dict[str, Any]] = Field(None, description='Extension metadata.')
    taskId: str = Field(..., description='Task id')


class TaskStatus(BaseModel):
    message: Optional[Message] = Field(
        None, description='Additional status updates for client'
    )
    state: TaskState
    timestamp: Optional[str] = Field(
        None, description='ISO 8601 datetime string when the status was recorded.'
    )


class TaskStatusUpdateEvent(BaseModel):
    contextId: str = Field(..., description='The context the task is associated with')
    final: bool = Field(..., description='Indicates the end of the event stream')
    kind: Literal['status-update'] = Field(..., description='Event type')
    metadata: Optional[Dict[str, Any]] = Field(None, description='Extension metadata.')
    status: TaskStatus = Field(..., description='Current status of the task')
    taskId: str = Field(..., description='Task id')


class A2ARequest(
    RootModel[
        Union[
            SendMessageRequest,
            SendStreamingMessageRequest,
            GetTaskRequest,
            CancelTaskRequest,
            SetTaskPushNotificationConfigRequest,
            GetTaskPushNotificationConfigRequest,
            TaskResubscriptionRequest,
        ]
    ]
):
    root: Union[
        SendMessageRequest,
        SendStreamingMessageRequest,
        GetTaskRequest,
        CancelTaskRequest,
        SetTaskPushNotificationConfigRequest,
        GetTaskPushNotificationConfigRequest,
        TaskResubscriptionRequest,
    ] = Field(..., description='A2A supported request types')


class AgentCard(BaseModel):
    capabilities: AgentCapabilities = Field(
        ..., description='Optional capabilities supported by the agent.'
    )
    defaultInputModes: List[str] = Field(
        ...,
        description='The set of interaction modes that the agent supports across all skills. This can be overridden per-skill.\nSupported media types for input.',
    )
    defaultOutputModes: List[str] = Field(
        ..., description='Supported media types for output.'
    )
    description: str = Field(
        ...,
        description='A human-readable description of the agent. Used to assist users and\nother agents in understanding what the agent can do.',
    )
    documentationUrl: Optional[str] = Field(
        None, description='A URL to documentation for the agent.'
    )
    iconUrl: Optional[str] = Field(None, description='A URL to an icon for the agent.')
    name: str = Field(..., description='Human readable name of the agent.')
    provider: Optional[AgentProvider] = Field(
        None, description='The service provider of the agent'
    )
    security: Optional[List[Dict[str, List[str]]]] = Field(
        None, description='Security requirements for contacting the agent.'
    )
    securitySchemes: Optional[Dict[str, SecurityScheme]] = Field(
        None,
        description='Security scheme details used for authenticating with this agent.',
    )
    skills: List[AgentSkill] = Field(
        ..., description='Skills are a unit of capability that an agent can perform.'
    )
    supportsAuthenticatedExtendedCard: Optional[bool] = Field(
        None,
        description='true if the agent supports providing an extended agent card when the user is authenticated.\nDefaults to false if not specified.',
    )
    url: str = Field(..., description='A URL to the address the agent is hosted at.')
    version: str = Field(
        ..., description='The version of the agent - format is up to the provider.'
    )


class Task(BaseModel):
    artifacts: Optional[List[Artifact]] = Field(
        None, description='Collection of artifacts created by the agent.'
    )
    contextId: str = Field(
        ...,
        description='Server-generated id for contextual alignment across interactions',
    )
    history: Optional[List[Message]] = None
    id: str = Field(..., description='Unique identifier for the task')
    kind: Literal['task'] = Field(..., description='Event type')
    metadata: Optional[Dict[str, Any]] = Field(None, description='Extension metadata.')
    status: TaskStatus = Field(..., description='Current status of the task')


class CancelTaskSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ...,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )
    result: Task = Field(..., description='The result object on success.')


class GetTaskSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ...,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )
    result: Task = Field(..., description='The result object on success.')


class SendMessageSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ...,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )
    result: Union[Task, Message] = Field(
        ..., description='The result object on success'
    )


class SendStreamingMessageSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ...,
        description='An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ...,
        description='Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".',
    )
    result: Union[Task, Message, TaskStatusUpdateEvent, TaskArtifactUpdateEvent] = (
        Field(..., description='The result object on success')
    )


class CancelTaskResponse(
    RootModel[Union[JSONRPCErrorResponse, CancelTaskSuccessResponse]]
):
    root: Union[JSONRPCErrorResponse, CancelTaskSuccessResponse] = Field(
        ..., description="JSON-RPC response for the 'tasks/cancel' method."
    )


class GetTaskResponse(RootModel[Union[JSONRPCErrorResponse, GetTaskSuccessResponse]]):
    root: Union[JSONRPCErrorResponse, GetTaskSuccessResponse] = Field(
        ..., description="JSON-RPC response for the 'tasks/get' method."
    )


class JSONRPCResponse(
    RootModel[
        Union[
            JSONRPCErrorResponse,
            SendMessageSuccessResponse,
            SendStreamingMessageSuccessResponse,
            GetTaskSuccessResponse,
            CancelTaskSuccessResponse,
            SetTaskPushNotificationConfigSuccessResponse,
            GetTaskPushNotificationConfigSuccessResponse,
        ]
    ]
):
    root: Union[
        JSONRPCErrorResponse,
        SendMessageSuccessResponse,
        SendStreamingMessageSuccessResponse,
        GetTaskSuccessResponse,
        CancelTaskSuccessResponse,
        SetTaskPushNotificationConfigSuccessResponse,
        GetTaskPushNotificationConfigSuccessResponse,
    ] = Field(..., description='Represents a JSON-RPC 2.0 Response object.')


class SendMessageResponse(
    RootModel[Union[JSONRPCErrorResponse, SendMessageSuccessResponse]]
):
    root: Union[JSONRPCErrorResponse, SendMessageSuccessResponse] = Field(
        ..., description="JSON-RPC response model for the 'message/send' method."
    )


class SendStreamingMessageResponse(
    RootModel[Union[JSONRPCErrorResponse, SendStreamingMessageSuccessResponse]]
):
    root: Union[JSONRPCErrorResponse, SendStreamingMessageSuccessResponse] = Field(
        ..., description="JSON-RPC response model for the 'message/stream' method."
    )
