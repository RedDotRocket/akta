---
description: 
globs: 
alwaysApply: true
---
## Security

As this is a project with a security nature to it, any code produced must be generated with security as a first principal:

Access Control
- Enforce least privilege: validate user permissions on every request.
- Tie permissions checks to your crypto layer (e.g. only release decryption keys if the user’s role allows it).

Cryptographic Failures
- Encrypt sensitive data in transit and at rest using up-to-date algorithms (AES-GCM, ChaCha20-Poly1305).
- Use Authenticated Encryption (AEAD) to ensure integrity and confidentiality.
- Design code so that keys in time can be stored in HSMs or secure enclaves and rotated regularly.

Injection
- Use parameterized queries or ORM methods; never concatenate untrusted input.
- Sanitize inputs even in crypto routines (e.g. when parsing serialized ciphertext or tokens).

Secure Design
- Apply threat modeling early and bake in secure architecture patterns.
- Formally verify or peer-audit core crypto and state-machine logic.

 Security Misconfiguration
- Automate hardened defaults; remove unused features and review configs regularly.
- Disable or tightly configure all protocol features you don’t need (e.g. avoid legacy ciphers, disable HTTP TRACE).

Avoid Vulnerable and Outdated Components
- Track dependencies and apply updates or patches promptly.
- Sign and verify code dependencies; use CI/CD integrity checks to catch supply-chain tampering.

Identification and Authentication
- Implement multi-factor auth and secure session management controls.
- Use short-lived, single-use tokens (JWTs with narrow `exp` and `jti`).
- Embed sequence numbers or timestamps in each token and reject duplicates to thwart replay.

Software and Data Integrity
- Sign and verify code dependencies; use CI/CD with integrity checks.
- Check signatures on all external data (firmware updates, container images, plugin packages).

Security Logging and Monitoring Failures
- Log critical events centrally and alert on anomalies in real time.
- Record crypto-relevant events (key usage, replay rejections) to an immutable audit trail.

Server-Side Request Forgery (SSRF)
 - Whitelist and validate external URLs; disable unnecessary request capabilities.
 - For any proxied crypto-related endpoint, enforce strict hostname and port checks.

API & Transport Hardening
 - Maintain and enforce a strict CORS policy.
 - Set secure HTTP headers (HSTS, CSP, X-Frame-Options, X-Content-Type-Options).

Credential & Session Lifecycle
• Build a revocation mechanism for VCs and tokens (e.g. revocation lists, OCSP-style lookups).
• Shorten session lifetimes and require re-authentication for high-sensitivity operations.
• Tie session state to device or fingerprint information to detect token export/replay.

---

### Additional Anti-Replay & Crypto-Core Controls

- Nonce/IV Hygiene: generate nonces with a CSPRNG; never reuse under the same key.
- Anti-Replay Cache: keep a sliding “seen” window of recent nonces/timestamps to drop duplicates.
- Mutual Authentication & Channel Binding: use mTLS and bind session tokens to that TLS channel.
- Strict Time Sync: NTP‐sync all nodes (with authentication) so timestamp checks are reliable.
- Side-Channel Protections: adopt constant-time implementations; guard against timing and cache attacks.
- Rate Limiting & Fail-Safe Defaults: default to “deny” on errors, throttle repeated invalid or replayed requests.

